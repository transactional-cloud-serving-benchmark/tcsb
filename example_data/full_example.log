# Generate debug commands.
$ ./artifacts/generate_commands keyvalue gold_memory exec debug seed=4321,write_ratio=0.25,command_count=1000,key_ordering=sorted,key_len=10,val_len=10,write_batch_size=10 > commands.kv.debug.txt

# Inspect the first debug commands.
$ head -n 20 commands.kv.debug.txt
0 0 0 w aaaaaaaaaa zomvtmqeym
1 0 1 w aaaaaaaaab bomzplglwh
2 0 2 w aaaaaaaaac oqfowotylo
3 0 3 w aaaaaaaaad acjnyrzcem
4 0 4 w aaaaaaaaae yvimyuxtwv
5 0 5 w aaaaaaaaaf vvdmnutjtc
6 0 6 w aaaaaaaaag nllvnqjphy
7 0 7 w aaaaaaaaah hoopxadxiu
8 0 8 w aaaaaaaaai usztinugsq
9 0 9 w aaaaaaaaaj qdxuaglemk
10 1 0 r aaaaaaaaac
11 2 0 r aaaaaaaaaa
12 3 0 r aaaaaaaaaf
13 4 0 r aaaaaaaaaa
14 5 0 r aaaaaaaaaa
15 6 0 r aaaaaaaaai
16 7 0 r aaaaaaaaai
17 8 0 r aaaaaaaaad
18 9 0 r aaaaaaaaaa
19 10 0 r aaaaaaaaaa

# Show that 25% of the commands are writes.
$ cut -f 4 -d\  commands.kv.debug.txt | sort | uniq -c
    750 r
    250 w

# Generate the binary commands (note that the `gold_memory` format is valid for Mongo, too, but that may change in the near future).
$ ./artifacts/generate_commands keyvalue gold_memory exec binary seed=4321,write_ratio=0.25,command_count=1000,key_ordering=sorted,key_len=10,val_len=10,write_batch_size=10 > commands.kv.binary.dat

# Check the size of the generated command file.
$ du -h commands.kv.binary.dat
96K     commands.kv.binary.dat

# Execute a gold memory benchmark, using the burn-in and validation commands.
# Burn-in is the number of operations that are initially skipped for statistics collection, to allow the system to warm up.
# Validation is the recording of key/value read requests, to compare correctness amongst different driver implementations.
# The `cmd` argument specifies the subprocess that the IPC driver will launch.
# Note that the gold_ram_kv program stores data in-process, and does not connect to a server.
$ cat commands.kv.binary.dat | ../artifacts/ipc_driver --burn-in=100 --validation=200 --validation-filename=validation-gold.txt --cmd="../artifacts/ipc_client_ephemeral_kv"
Validation: 200
Validation filename: validation-gold.txt
Burn-in: 100
cmd: ../artifacts/ipc_client_ephemeral_kv
2019/05/18 06:52:24 benchmark complete:
  200 read operations logged for validation
  100 operations executed before beginning statistics collection (burn-in)
  654 read batch requests
  21 write batch requests
  654 read operations
  210 write operations
  864 total operations
  23373.5 write ops/sec
  72791.9 read ops/sec


# Inspect the gold memory server validation output.
# Note that some values may be missing, because when we use parallel workers, writes and reads can sometimes occur out-of-order ( thereby causing some 404s).
# This is expected and fine.
$ head validation-gold.txt
aaaaaaaaac -> oqfowotylo
aaaaaaaaaa -> zomvtmqeym
aaaaaaaaaf -> vvdmnutjtc
aaaaaaaaaa -> zomvtmqeym
aaaaaaaaaa -> zomvtmqeym
aaaaaaaaai -> usztinugsq
aaaaaaaaai -> usztinugsq
aaaaaaaaad -> acjnyrzcem
aaaaaaaaaa -> zomvtmqeym
aaaaaaaaaa -> zomvtmqeym


# Start Mongo.
$ docker run -it --rm --net=bridge --expose=27017 -p 27017:27017 mongo:4.0.7-xenial 1>/dev/null 2>&1 &

# Execute a Mongo benchmark, using the burn-in, validation, and worker-level parallelism commands.
$ cat commands.kv.binary.dat | ../artifacts/ipc_driver --burn-in=100 --validation=200 --validation-filename=validation-mongo.txt --cmd="../artifacts/ipc_client_mongo --address=mongodb://127.0.0.1:27017 --workers=4"
Validation: 200
Validation filename: validation-mongo.txt
Burn-in: 100
cmd: ../artifacts/ipc_client_mongo --address=mongodb://127.0.0.1:27017 --workers=4
2019/05/18 07:32:44 benchmark complete:
  200 read operations logged for validation
  100 operations executed before beginning statistics collection (burn-in)
  654 read batch requests
  21 write batch requests
  654 read operations
  210 write operations
  864 total operations
  363.2 write ops/sec
  1131.1 read ops/sec

# Check the validation results from the gold memory benchmark, and the Mongo benchmark, are comparable.
# Observe that 4 of 200 lines differ.
# We conclude that the benchmark was correct, because only 2% of results differ.
# (The differences are nonzero due to use using parallel requests.)
$ wc -l validation-gold.txt validation-mongo.txt
  200 validation-gold.txt
  200 validation-mongo.txt
  400 total
$ diff -y --suppress-common-lines <(sort validation-gold.txt) <(sort validation-mongo.txt) | wc -l
4

# Stop Mongo.
$ kill %1

# Start Redis.
$ docker run -it --rm  --net=bridge --expose=6379 -p 6379:6379 redis:5.0-alpine 1>/dev/null 2>&1 &

# Execute a Redis benchmark, using the burn-in, validation, and worker-level parallelism commands.
$ cat commands.kv.binary.dat | ../artifacts/ipc_driver --burn-in=100 --validation=200 --validation-filename=validation-redis.txt --cmd="../artifacts/ipc_client_redis --address=:6379 --workers=4"
Validation: 200
Validation filename: validation-redis.txt
Burn-in: 100
cmd: ../artifacts/ipc_client_redis --address=:6379 --workers=4
2019/05/18 07:43:59 benchmark complete:
  200 read operations logged for validation
  100 operations executed before beginning statistics collection (burn-in)
  654 read batch requests
  21 write batch requests
  654 read operations
  210 write operations
  864 total operations
  986.5 write ops/sec
  3072.4 read ops/sec

# Stop Redis.
$ kill %1

# Check the validation results from the gold memory benchmark, and the Redis benchmark, are comparable.
# Observe that 6 of 200 lines differ.
# We conclude that the benchmark was correct, because only 3% of results differ.
# (The differences are nonzero due to use using parallel requests.)
$ wc -l validation-gold.txt validation-redis.txt
  200 validation-gold.txt
  200 validation-redis.txt
  400 total
$ diff -y --suppress-common-lines <(sort validation-gold.txt) <(sort validation-redis.txt) | wc -l
6

# Start YugabyteDB.
$ python yb-docker-ctl start

# Execute a YugabyteDB benchmark with the Cassandra protocol, using the burn-in, validation, and worker-level parallelism commands.
$ cat commands.kv.binary.dat | ../artifacts/ipc_driver --burn-in=100 --validation=200 --validation-filename=validation-ydb-cassandra.txt --cmd="../artifacts/ipc_client_cassandra --addresses=127.0.0.1 --workers=4"
Validation: 200
Validation filename: validation-ydb-cassandra.txt
Burn-in: 100
cmd: ../artifacts/ipc_client_cassandra --addresses=127.0.0.1 --workers=4
2019/05/18 07:12:40 benchmark complete:
  200 read operations logged for validation
  100 operations executed before beginning statistics collection (burn-in)
  654 read batch requests
  21 write batch requests
  654 read operations
  210 write operations
  864 total operations
  449.0 write ops/sec
  1398.2 read ops/sec

# Stop YugabyteDB.
$ python yb-docker-ctl stop

# Check the validation results from the gold memory benchmark, and the YugabyteDB Cassandra-protocol benchmark, are comparable.
# See that that 10 of 200 lines differ.
# We conclude that the benchmark was correct, because only 5% of results differ.
# (The differences are nonzero due to use using parallel requests.)
$ wc -l validation-gold.txt validation-ydb-cassandra.txt
  200 validation-gold.txt
  200 validation-ydb-cassandra.txt
  400 total
$ diff -y --suppress-common-lines <(sort validation-gold.txt) <(sort validation-ydb-cassandra.txt) | wc -l
7
